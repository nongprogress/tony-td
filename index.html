<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Idle TD ‚Äî The Art of War Update v1.4 (Play‚Äëready)</title>
<style>
  :root{
    --bg:#0b1220; --card:#0f172a; --line:#243041; --ink:#e2e8f0; --mut:#a8b3c7;
    --pri:#22d3ee; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444; --yel:#facc15;
    --safe:#2e7d32; --ore:#8d6e63; --bal:#2962ff; --lava:#b91c1c; --ice:#38bdf8; --sand:#ca8a04;
    /* Biome Colors */
    --bg-grassland: #166534; --path-grassland: #a16207;
    --bg-desert: #b45309; --path-desert: #fde68a;
    --bg-frostlands: #075985; --path-frostlands: #e0f2fe;
    --bg-volcanic: #4f46e5; --path-volcanic: #1e293b;
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%;margin:0}
  body{background:var(--bg);color:var(--ink);font:14px system-ui,Segoe UI,Roboto}
  .wrap{max-width:1400px;margin:0 auto;padding:12px}
  header{position:sticky;top:0;background:#0b1220cc;border-bottom:1px solid var(--line);backdrop-filter:blur(8px);z-index:10}
  .hud{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:space-between;padding:8px 0}
  .pill{display:flex;align-items:center;gap:6px;background:var(--card);border:1px solid var(--line);border-radius:999px;padding:6px 10px; font-size: 12px;}
  .btn{cursor:pointer;border:1px solid var(--line);background:linear-gradient(180deg,#1b2636,#131b28);color:var(--ink);padding:8px 12px;border-radius:10px}
  .btn:hover{border-color:#3b4a63}
  .btn:disabled{background:#111a2a; color:var(--mut); border-color:var(--line); cursor:not-allowed;}
  .gridWrap{display:grid;grid-template-columns:1fr;gap:12px}
  canvas{display:block;width:100%;height:auto;border:1px solid var(--line); border-radius: 12px; cursor: crosshair; background:#0b1220;}
  .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:10px}
  .row{display:flex;flex-wrap:wrap;gap:8px}
  .list{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
  @media (min-width:1000px){.gridWrap{grid-template-columns:3fr 1fr}}
  /* Modal Styles */
  .modal{position:fixed;inset:0;background:rgba(2,6,23,.8);backdrop-filter:blur(4px);display:flex;align-items:center;justify-content:center;z-index:100; opacity: 0; visibility: hidden; transition: opacity .2s, visibility .2s;}
  .modal.visible{opacity:1; visibility: visible;}
  .modal-content{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:14px;width:90%;max-width:960px;max-height:85vh;overflow-y:auto}
  .modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .tier{border:1px solid var(--line); padding:10px; border-radius:10px; margin-bottom:10px; background: #0b1220;}
  .tier h4{margin:0 0 8px;}
  .tier p{font-size:12px; color:var(--mut); margin: 0 0 8px;}
  #loadingOverlay{color:white; font-size:1.1em; text-align: center;}
</style>
</head>
<body>
  <header class="wrap">
    <div class="hud">
      <div class="row">
        <div class="pill">üèõÔ∏è ‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û: <b id="citadelHP">100</b>/<b id="citadelMaxHP">100</b> (Tier <b id="citadelTier">1</b>)</div>
        <div class="pill">üí∞ <b id="gold">0</b></div>
        <div class="pill">‚õèÔ∏è <b id="ore">0</b></div>
        <div class="pill">‚öôÔ∏è <b id="components">0</b></div>
        <div class="pill">üî© <b id="gears">0</b></div>
        <div class="pill">üíé <b id="cores">0</b></div>
        <div class="pill">üåä Wave <b id="wave">0</b></div>
      </div>
      <div class="row">
        <button class="btn" id="btnStart" disabled>‚ñ∂ Start Wave</button>
        <button class="btn" id="btnCitadel">üèõÔ∏è ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û</button>
        <button class="btn" id="btnSpeed">‚è© Speed x1</button>
      </div>
    </div>
  </header>

  <main class="wrap gridWrap">
    <section>
      <canvas id="game" width="1280" height="720"></canvas>
    </section>
    <aside class="panel">
      <h3 style="margin:0 0 8px">‡∏™‡∏¥‡πà‡∏á‡∏Å‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á (Tier <span id="buildTier">1</span>)</h3>
      <div class="list" id="buildMenu"></div>
      <h3 style="margin:12px 0 8px">‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å</h3>
      <div id="selectedInfo" class="panel" style="min-height:120px; background:#0b1220; padding:8px;">
        <small style="color:var(--mut)">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏õ‡πâ‡∏≠‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î</small>
      </div>
      <div class="panel" style="margin-top:12px">
        <b>‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô</b>
        <ol style="margin:6px 0 0 18px; padding:0">
          <li>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏•‡∏Å ‚Üí ‡∏Å‡∏î "‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏ê‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà"</li>
          <li>‡∏Å‡∏î‡∏™‡∏£‡πâ‡∏≤‡∏á <i>‡∏õ‡πâ‡∏≠‡∏°‡∏õ‡∏∑‡∏ô‡∏Å‡∏•</i> ‡∏´‡∏£‡∏∑‡∏≠ <i>‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏á‡πÅ‡∏£‡πà</i> ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏á (‡∏´‡πâ‡∏≤‡∏°‡∏ß‡∏≤‡∏á‡∏ö‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô)</li>
          <li>‡∏Å‡∏î ‚ñ∂ Start Wave ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏®‡∏∂‡∏Å</li>
          <li>‡∏Ñ‡∏•‡∏¥‡∏Å‡∏õ‡πâ‡∏≠‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏Ñ‡πà‡∏≤ DMG/Range/Rate</li>
        </ol>
      </div>
    </aside>
  </main>

  <!-- Citadel Upgrade Modal -->
  <div id="citadelModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û</h2>
        <button id="closeCitadelModal" class="btn">√ó</button>
      </div>
      <div id="citadelTiers"></div>
    </div>
  </div>
  
  <!-- World Select Overlay -->
  <div id="worldOverlay" class="modal visible">
    <div id="loadingOverlay" style="display:none;">
      <p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£... (assets)</p>
    </div>
    <div id="selectionContent" class="modal-content" style="max-width: 960px;">
      <h3>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏±‡πâ‡∏á‡∏ê‡∏≤‡∏ô‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏•‡∏Å</h3>
      <p style="margin:0 0 8px;color:var(--mut)">‡πÅ‡∏ï‡∏∞/‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ä‡πà‡∏≠‡∏á‡∏™‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏π‡∏°‡∏¥‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏® ‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏î‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô</p>
      <div class="legend" style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px;">
        <span><i style="display:inline-block;width:10px;height:10px;background:var(--safe);border-radius:2px"></i> ‡∏ó‡∏∏‡πà‡∏á‡∏´‡∏ç‡πâ‡∏≤</span>
        <span><i style="display:inline-block;width:10px;height:10px;background:var(--sand);border-radius:2px"></i> ‡∏ó‡∏∞‡πÄ‡∏•‡∏ó‡∏£‡∏≤‡∏¢</span>
        <span><i style="display:inline-block;width:10px;height:10px;background:var(--ice);border-radius:2px"></i> ‡πÅ‡∏î‡∏ô‡∏ô‡πâ‡∏≥‡πÅ‡∏Ç‡πá‡∏á</span>
        <span><i style="display:inline-block;width:10px;height:10px;background:var(--lava);border-radius:2px"></i> ‡πÄ‡∏Ç‡∏ï‡∏†‡∏π‡πÄ‡∏Ç‡∏≤‡πÑ‡∏ü</span>
      </div>
      <canvas id="world" width="960" height="540"></canvas>
      <div id="zonePreview" style="margin-top:10px; min-height: 40px;">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà...</div>
      <button class="btn" id="btnConfirm" disabled style="width:100%; margin-top:10px;">‚úÖ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏ê‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</button>
    </div>
  </div>

<script>
(async function(){
  // =========================
  // ASSET MANAGER
  // =========================
  const AssetManager = {
    images: {},
    imageUrls: {
      // Towers
      GUN_BASE: 'https://placehold.co/64x64/78716c/3f3f46.png?text=Base',
      GUN_TURRET: 'https://placehold.co/64x64/22d3ee/1e293b.png?text=II',
      FROST_BASE: 'https://placehold.co/64x64/78716c/3f3f46.png?text=Base',
      FROST_TURRET: 'https://placehold.co/64x64/38bdf8/1e293b.png?text=%E2%9D%84',
      ROCKET_BASE: 'https://placehold.co/64x64/78716c/3f3f46.png?text=Base',
      ROCKET_TURRET: 'https://placehold.co/64x64/f59e0b/1e293b.png?text=%F0%9F%9A%80',
      ARTILLERY_BASE: 'https://placehold.co/64x64/78716c/3f3f46.png?text=Base',
      ARTILLERY_TURRET: 'https://placehold.co/64x64/64748b/1e293b.png?text=%F0%9F%92%A3',
      // Buildings
      MINE: 'https://placehold.co/64x64/ca8a04/422006.png?text=Mine',
      BARRACKS: 'https://placehold.co/64x64/e2e8f0/475569.png?text=Fort',
      // Enemies
      RUNNER: 'https://placehold.co/48x48/ef4444/7f1d1d.png?text=R',
      BRUTE: 'https://placehold.co/64x64/a855f7/581c87.png?text=B',
      FLYER: 'https://placehold.co/48x48/eab308/713f12.png?text=F',
      BOSS: 'https://placehold.co/80x80/dc2626/450a0a.png?text=BOSS',
      // Effects
      BULLET: 'https://placehold.co/16x16/fef08a/fef08a.png'
    },
    async loadAssets() {
      const promises = Object.entries(this.imageUrls).map(([key, url]) => new Promise((resolve, reject) => {
        const img = new Image(); img.src = url; img.onload = () => { this.images[key] = img; resolve(); }; img.onerror = () => resolve(); // don't hard fail
      }));
      await Promise.all(promises);
    },
    get(key) { return this.images[key]; }
  };

  // =========================
  // GAME CONFIGURATION
  // =========================
  const CONFIG = {
    GRID: { COLS: 24, ROWS: 14 },
    CITADEL_TIERS: {
      1: { hp: 100, unlocks: ['GUN', 'MINE'] },
      2: { hp: 150, cost: { gold: 500, components: 50 }, unlocks: ['FROST', 'ROCKET'] },
      3: { hp: 220, cost: { gold: 1200, gears: 25 }, unlocks: ['ARTILLERY', 'BARRACKS'] },
      4: { hp: 350, cost: { gold: 3000, cores: 5 }, unlocks: ['METEOR_STRIKE'] }
    },
    TOWER_TYPES: {
      GUN: { name: '‡∏õ‡πâ‡∏≠‡∏°‡∏õ‡∏∑‡∏ô‡∏Å‡∏•', tier: 1, cost: { gold: 30, ore: 0 }, stats: { dmg: 35, range: 2.3, rate: 0.9, projectileSpeed: 450 }, upgrades: { dmg: { cost: {ore:10}, val: 1.2 }, range: { cost: {ore:15}, val: 1.1 }, rate: { cost: {ore:12}, val: 1.15 } } },
      FROST: { name: '‡∏õ‡πâ‡∏≠‡∏°‡∏ô‡πâ‡∏≥‡πÅ‡∏Ç‡πá‡∏á', tier: 2, cost: { gold: 80, ore: 10 }, stats: { dmg: 45, range: 2.1, rate: 1.2, slow: 0.35, projectileSpeed: 350 }, upgrades: { dmg: { cost: {ore:15}, val: 1.3 }, range: { cost: {ore:15}, val: 1.1 }, slow: { cost: {ore:30}, val: 1.2 } } },
      ROCKET: { name: '‡∏õ‡πâ‡∏≠‡∏°‡∏à‡∏£‡∏ß‡∏î', tier: 2, cost: { gold: 120, ore: 30 }, prerequisite: 'BARRACKS', stats: { dmg: 40, range: 2.8, rate: 0.4, splash: 1.0, projectileSpeed: 300 }, upgrades: { dmg: { cost: {ore:40}, val: 1.25 }, range: { cost: {ore:30}, val: 1.08 }, splash: { cost: {ore:50}, val: 1.2 } } },
      ARTILLERY: { name: '‡∏õ‡πâ‡∏≠‡∏°‡∏õ‡∏∑‡∏ô‡πÉ‡∏´‡∏ç‡πà', tier: 3, cost: { gold: 200, ore: 50 }, stats: { dmg: 80, range: 4.5, rate: 0.25, splash: 1.5, minRange: 1.8, projectileSpeed: 200 }, upgrades: { dmg: { cost: {ore:80}, val: 1.2 }, range: { cost: {ore:60}, val: 1.1 }, splash: { cost: {ore:100}, val: 1.15 } } }
    },
    BUILDING_TYPES: {
      MINE: { name: '‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏á‡πÅ‡∏£‡πà', tier: 1, cost: { gold: 40, ore: 0 }, stats: { rate: 5, yield: 2 } },
      BARRACKS: { name: '‡∏Ñ‡πà‡∏≤‡∏¢‡∏ó‡∏´‡∏≤‡∏£', tier: 3, cost: { gold: 150, ore: 20 }, limit: 1 }
    },
    ENEMY_TYPES: {
      RUNNER: { hp: 80, speed: 60, reward: 5, type: 'normal' },
      BRUTE: { hp: 250, speed: 40, reward: 12, type: 'elite' },
      FLYER: { hp: 100, speed: 75, reward: 8, type: 'normal', flying: true },
      BOSS: { hp: 2000, speed: 35, reward: 100, type: 'boss' }
    },
    WAVE_COMPOSITION: [
      { RUNNER: 10 }, { RUNNER: 15 }, { RUNNER: 10, BRUTE: 2 }, { RUNNER: 20, FLYER: 5 }, { BRUTE: 8, FLYER: 5 },
      { RUNNER: 25, BRUTE: 5 }, { FLYER: 15, BRUTE: 5 }, { RUNNER: 20, BRUTE: 10 }, { BRUTE: 15, FLYER: 10 }, { BOSS: 1, RUNNER: 20 }
    ],
    BIOME_MODIFIERS: {
      GRASSLAND: { name: '‡∏ó‡∏∏‡πà‡∏á‡∏´‡∏ç‡πâ‡∏≤', desc: '‡∏™‡∏°‡∏î‡∏∏‡∏• ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏•‡∏û‡∏¥‡πÄ‡∏®‡∏©', color: 'var(--safe)', background: 'var(--bg-grassland)', path: 'var(--path-grassland)', mods: {} },
      DESERT: { name: '‡∏ó‡∏∞‡πÄ‡∏•‡∏ó‡∏£‡∏≤‡∏¢', desc: '‡∏õ‡πâ‡∏≠‡∏°‡∏¢‡∏¥‡∏á‡∏ä‡πâ‡∏≤‡∏•‡∏á 5%, ‡∏®‡∏±‡∏ï‡∏£‡∏π HP -10%', color: 'var(--sand)', background: 'var(--bg-desert)', path: 'var(--path-desert)', mods: { towerRate: 0.95, enemyHP: 0.9 } },
      FROSTLANDS: { name: '‡πÅ‡∏î‡∏ô‡∏ô‡πâ‡∏≥‡πÅ‡∏Ç‡πá‡∏á', desc: 'Frost Tower ‡∏™‡πÇ‡∏•‡∏ß‡πå x1.2, ‡∏õ‡πâ‡∏≠‡∏° AOE Dmg -15%', color: 'var(--ice)', background: 'var(--bg-frostlands)', path: 'var(--path-frostlands)', mods: { frostSlow: 1.2, splashDmg: 0.85 } },
      VOLCANIC: { name: '‡πÄ‡∏Ç‡∏ï‡∏†‡∏π‡πÄ‡∏Ç‡∏≤‡πÑ‡∏ü', desc: '‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏ï‡πâ‡∏≤‡∏ô‡∏ó‡∏≤‡∏ô AOE, ‡∏î‡∏£‡∏≠‡∏õ‡πÅ‡∏£‡πà‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô', color: 'var(--lava)', background: 'var(--bg-volcanic)', path: 'var(--path-volcanic)', mods: { enemySplashResist: 0.2, oreYield: 1.25 } }
    },
    ENEMY_DROPS: {
      normal: { components: 0.15, gears: 0.03 },
      elite: { components: 0.4,   gears: 0.10 },
      boss:   { components: 1.0,  gears: 0.5,  cores: 1.0 }
    }
  };

  const state = {
    mode: 'map-select', citadelTier: 1, citadelHP: 100,
    gold: 200, ore: 50, components: 0, gears: 0, cores: 0,
    wave: 0, speed: 1,
    towers: [], buildings: [], enemies: [], bullets: [], effects: [], decorations: [],
    path: [], pathGrid: new Set(),
    lastTime: 0, buildMode: null, selectedEntity: null,
    biome: 'GRASSLAND', mouse: {x:0, y:0},
    spawning: false
  };

  const game = document.getElementById('game');
  const g = game.getContext('2d');
  const buildMenu = document.getElementById('buildMenu');
  const btnStart = document.getElementById('btnStart');

  // Convenience cost helpers
  function canAfford(cost={}){ return Object.entries(cost).every(([k,v])=> (state[k]||0) >= v); }
  function pay(cost={}){ Object.entries(cost).forEach(([k,v])=> state[k]-=v); }

  // =========================
  // BASE ENTITIES
  // =========================
  class Entity { constructor(c, r) { this.c=c; this.r=r; const {x,y}=tileCenter(c,r); this.x=x; this.y=y; } center(){return {x:this.x,y:this.y}} update(dt){} draw(ctx){} }

  class Tower extends Entity {
    constructor(c,r,key){ super(c,r); this.key=key; this.type='tower'; this.def=CONFIG.TOWER_TYPES[key];
      this.stats=JSON.parse(JSON.stringify(this.def.stats)); this.cooldown=0; this.target=null; this.angle=0; this.level=1; }
    update(dt){ this.cooldown -= dt; if(this.target && (!this.target.alive || dist(this.x,this.y,this.target.x,this.target.y) > this.stats.range * TS().w)) this.target=null; if(!this.target) this.findTarget(); if(this.target){ this.angle=Math.atan2(this.target.y-this.y, this.target.x-this.x); if(this.cooldown<=0) this.shoot(); } }
    findTarget(){ let best=null, maxProg=-1; for(const e of state.enemies){ if(e.def.flying && this.key==='ROCKET') continue; const d=dist(this.x,this.y,e.x,e.y); if(d<=this.stats.range*TS().w && e.pathProgress>maxProg){ best=e; maxProg=e.pathProgress; } } this.target=best; }
    shoot(){ const rateMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.towerRate || 1; this.cooldown = 1 / (this.stats.rate * rateMod); state.bullets.push(new Bullet(this.x, this.y, this.target, this)); }
    draw(ctx){ const base=AssetManager.get(`${this.key}_BASE`); const turret=AssetManager.get(`${this.key}_TURRET`); const size=TS().w*0.8; if(base) ctx.drawImage(base, this.x-size/2,this.y-size/2,size,size); ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle+Math.PI/2); if(turret) ctx.drawImage(turret,-size/2,-size/2,size,size); ctx.restore(); if(state.selectedEntity===this){ ctx.save(); ctx.translate(this.x,this.y); ctx.beginPath(); ctx.globalAlpha=.2; ctx.fillStyle='#FFF'; ctx.arc(0,0,this.stats.range*TS().w,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; ctx.restore(); } }
  }

  class Building extends Entity {
    constructor(c,r,key){ super(c,r); this.key=key; this.type='building'; this.def=CONFIG.BUILDING_TYPES[key]; this.timer=0; }
    update(dt){ if(this.key==='MINE'){ this.timer += dt; if(this.timer>=this.def.stats.rate){ this.timer=0; const oreMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.oreYield || 1; const amt = Math.round(this.def.stats.yield*oreMod); state.ore += amt; state.effects.push(new FloatingText(`+${amt} Ore`, this.x, this.y)); } } }
    draw(ctx){ const img=AssetManager.get(this.key); const size=TS().w*.9; if(img) ctx.drawImage(img, this.x-size/2,this.y-size/2,size,size); }
  }

  class Enemy {
    constructor(key){ this.key=key; this.def=CONFIG.ENEMY_TYPES[key]; const start=state.path[0]; this.x=start.x; this.y=start.y; this.pathIndex=0; this.pathProgress=0; const hpMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.enemyHP || 1; this.maxHp=Math.floor(this.def.hp*(1+state.wave*0.1)*hpMod); this.hp=this.maxHp; this.alive=true; this.slowTimer=0; this.slowFactor=1; this.img=AssetManager.get(key); }
    update(dt){ if(this.slowTimer>0) this.slowTimer-=dt; else this.slowFactor=1; const target=state.path[this.pathIndex+1]; if(!target){ this.alive=false; state.citadelHP=Math.max(0,state.citadelHP-1); if(state.citadelHP<=0) toast('‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û‡∏ñ‡∏π‡∏Å‡∏ó‡∏≥‡∏•‡∏≤‡∏¢!'); return; } const angle=Math.atan2(target.y-this.y,target.x-this.x); const speed=this.def.speed*this.slowFactor*dt; this.x+=Math.cos(angle)*speed; this.y+=Math.sin(angle)*speed; this.pathProgress+=speed; if(dist(this.x,this.y,target.x,target.y)<5) this.pathIndex++; }
    takeDamage(dmg, splashResistMod = 0){ const finalDmg = dmg * (1 - splashResistMod); this.hp -= finalDmg; if(this.hp<=0){ this.alive=false; state.gold += this.def.reward; // drops
        const table = CONFIG.ENEMY_DROPS[this.def.type] || {}; for(const [res,prob] of Object.entries(table)){ if(Math.random()<prob){ state[res]=(state[res]||0)+1; state.effects.push(new FloatingText(`+1 ${res}`, this.x, this.y)); } }
      }
    }
    draw(ctx){ const size = (this.key==='BOSS')?40:24; if(this.img) ctx.drawImage(this.img, this.x-size, this.y-size, size*2, size*2);
      if(this.slowTimer>0){ ctx.strokeStyle='#38bdf8'; ctx.lineWidth=2; ctx.globalAlpha=.7; ctx.beginPath(); ctx.arc(this.x,this.y,size,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }
      // HP bar
      const barY=this.y-size-5; ctx.fillStyle='#1e293b'; ctx.fillRect(this.x-15,barY,30,4); ctx.fillStyle='#16a34a'; ctx.fillRect(this.x-15,barY,30*(this.hp/this.maxHp),4);
    }
  }

  class Bullet { constructor(x,y,target,tower){ this.x=x; this.y=y; this.target=target; this.tower=tower; this.alive=true; this.img=AssetManager.get('BULLET'); }
    update(dt){ if(!this.target || !this.target.alive){ this.alive=false; return; } const angle=Math.atan2(this.target.y-this.y,this.target.x-this.x); const speed=this.tower.stats.projectileSpeed*dt; this.x+=Math.cos(angle)*speed; this.y+=Math.sin(angle)*speed; if(dist(this.x,this.y,this.target.x,this.target.y)<10) this.hit(); }
    hit(){ this.alive=false; const splashMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.splashDmg || 1; const splashResistMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.enemySplashResist || 0; if(this.tower.stats.splash>0){ state.effects.push(new Explosion(this.target.x,this.target.y,this.tower.stats.splash*TS().w)); for(const e of state.enemies){ if(dist(this.target.x,this.target.y,e.x,e.y) < this.tower.stats.splash*TS().w){ e.takeDamage(this.tower.stats.dmg*splashMod, splashResistMod); } } } else { this.target.takeDamage(this.tower.stats.dmg); } if(this.tower.stats.slow>0){ const slowMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.frostSlow || 1; this.target.slowFactor = Math.max(0.2, 1 - (this.tower.stats.slow*slowMod)); this.target.slowTimer = 2; } }
    draw(ctx){ if(this.img) ctx.drawImage(this.img, this.x-4, this.y-4, 8, 8); }
  }

  class Effect { constructor(x,y){ this.x=x; this.y=y; this.alive=true; this.life=1; } update(dt){ this.life-=dt; if(this.life<=0) this.alive=false; } draw(ctx){} }
  class Explosion extends Effect { constructor(x,y,radius){ super(x,y); this.radius=radius; this.life=.4; } draw(ctx){ const p=1-(this.life/.4); ctx.beginPath(); ctx.arc(this.x,this.y,this.radius*p,0,Math.PI*2); ctx.fillStyle=`rgba(251,146,60,${1-p})`; ctx.fill(); } }
  class FloatingText extends Effect { constructor(text,x,y){ super(x,y); this.text=text; this.life=1.2; } update(dt){ super.update(dt); this.y -= 20*dt; } draw(ctx){ ctx.font='bold 12px Segoe UI'; ctx.fillStyle=`rgba(250,250,250,${this.life/1.2})`; ctx.textAlign='center'; ctx.fillText(this.text,this.x,this.y); } }

  // =========================
  // CORE LOOP / SYSTEMS
  // =========================
  function initGame(){ resize(); window.addEventListener('resize', resize); game.addEventListener('mousemove', e=>{ const rect=game.getBoundingClientRect(); state.mouse.x=e.clientX-rect.left; state.mouse.y=e.clientY-rect.top; }); game.addEventListener('click', handleCanvasClick); buildPath(); updateCitadelUI(); updateBuildMenu(); updateHUD(); state.citadelHP=CONFIG.CITADEL_TIERS[state.citadelTier].hp; generateDecorations(); btnStart.disabled=false; loop(0); }

  function generateDecorations(){ state.decorations.length=0; for(let i=0;i<50;i++){ const c=Math.floor(Math.random()*CONFIG.GRID.COLS); const r=Math.floor(Math.random()*CONFIG.GRID.ROWS); if(!state.pathGrid.has(`${c},${r}`)) state.decorations.push({c,r}); } }

  function startWave(){ if(state.mode!=='play') return toast('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡πà‡∏≠‡∏ô'); if(state.enemies.length>0 || state.spawning) return toast('‡∏Å‡∏≥‡∏à‡∏±‡∏î‡∏®‡∏±‡∏ï‡∏£‡∏π‡πÉ‡∏´‡πâ‡∏´‡∏°‡∏î‡∏Å‡πà‡∏≠‡∏ô'); state.wave++; const waveData = CONFIG.WAVE_COMPOSITION[(state.wave-1)%CONFIG.WAVE_COMPOSITION.length]; let spawnQueue=[]; for(const [key,count] of Object.entries(waveData)) for(let i=0;i<count;i++) spawnQueue.push(key); state.spawning=true; btnStart.disabled=true; const spawnInterval=setInterval(()=>{ if(spawnQueue.length>0){ state.enemies.push(new Enemy(spawnQueue.shift())); } else { clearInterval(spawnInterval); state.spawning=false; } }, Math.max(150, 800/state.speed)); }

  function handleCanvasClick(){ const {c,r}=worldToTile(state.mouse.x,state.mouse.y); if(c<0||r<0||c>=CONFIG.GRID.COLS||r>=CONFIG.GRID.ROWS) return; if(state.buildMode){ placeEntity(c,r); } else { const clicked=[...state.towers,...state.buildings].find(e=>e.c===c&&e.r===r); state.selectedEntity=clicked||null; updateSelectedInfo(); } }

  function placeEntity(c,r){ if(state.pathGrid.has(`${c},${r}`)) return toast('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏î‡πâ'); if([...state.towers,...state.buildings].some(e=>e.c===c&&e.r===r)) return toast('‡∏°‡∏µ‡∏™‡∏¥‡πà‡∏á‡∏Å‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß'); const key=state.buildMode; const isTower = !!CONFIG.TOWER_TYPES[key]; const def = isTower?CONFIG.TOWER_TYPES[key]:CONFIG.BUILDING_TYPES[key]; // prerequisite / limits
    if(!isTower && key==='BARRACKS' && state.buildings.some(b=>b.key==='BARRACKS')) return toast('‡∏Ñ‡πà‡∏≤‡∏¢‡∏ó‡∏´‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏î‡πâ 1 ‡πÅ‡∏´‡πà‡∏á');
    if(isTower && def.prerequisite && !state.buildings.some(b=>b.key===def.prerequisite)) return toast(`‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ ${CONFIG.BUILDING_TYPES[def.prerequisite].name} ‡∏Å‡πà‡∏≠‡∏ô`);
    const cost = def.cost||{}; if(!canAfford(cost)) return toast('‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡πÑ‡∏°‡πà‡∏û‡∏≠'); pay(cost);
    if(isTower) state.towers.push(new Tower(c,r,key)); else state.buildings.push(new Building(c,r,key)); state.buildMode=null; updateHUD(); }

  function loop(ts){ if(!state.lastTime) state.lastTime=ts; const dt=Math.min(.05,(ts-state.lastTime)/1000); state.lastTime=ts; const updateDt=dt*state.speed; update(updateDt); draw(); requestAnimationFrame(loop); }

  function update(dt){ if(state.mode!=='play') return; for(const t of state.towers) t.update(dt); for(const b of state.buildings) b.update(dt); state.bullets=state.bullets.filter(b=>b.alive); for(const b of state.bullets) b.update(dt); state.enemies=state.enemies.filter(e=>e.alive); for(const e of state.enemies) e.update(dt); state.effects=state.effects.filter(e=>e.alive); for(const e of state.effects) e.update(dt); // re-enable Start when wave done
    if(!state.spawning && state.enemies.length===0 && state.wave>0) btnStart.disabled=false; updateHUD(); }

  function draw(){ const root = getComputedStyle(document.documentElement); const biomeBg = root.getPropertyValue(`--bg-${state.biome.toLowerCase()}`).trim(); const pathColor = root.getPropertyValue(`--path-${state.biome.toLowerCase()}`).trim(); g.fillStyle=biomeBg||'#0b1220'; g.fillRect(0,0,game.width,game.height); const ts=TS(); // path nodes
    g.fillStyle=pathColor||'#334155'; g.strokeStyle="#00000033"; g.lineWidth=2; for(const p of state.path){ g.beginPath(); g.arc(p.x,p.y, ts.w*.6, 0, Math.PI*2); g.fill(); g.stroke(); }
    // decorations
    g.fillStyle='#14532d'; for(const d of state.decorations){ const {x,y}=tileCenter(d.c,d.r); g.beginPath(); g.arc(x,y, 6+Math.random()*6, 0, Math.PI*2); g.fill(); }
    // entities & effects
    for(const e of state.buildings) e.draw(g); for(const e of state.towers) e.draw(g); for(const e of state.enemies) e.draw(g); for(const b of state.bullets) b.draw(g); for(const e of state.effects) e.draw(g);
    // placement preview
    if(state.buildMode){ const {c,r}=worldToTile(state.mouse.x,state.mouse.y); if(c>=0&&r>=0){ const {x,y}=tileCenter(c,r); const def=CONFIG.TOWER_TYPES[state.buildMode]||CONFIG.BUILDING_TYPES[state.buildMode]; const canPlace=!state.pathGrid.has(`${c},${r}`) && ![...state.towers,...state.buildings].some(e=>e.c===c&&e.r===r); g.globalAlpha=.45; g.fillStyle=canPlace?'#22c55e':'#ef4444'; g.fillRect(x-ts.w/2,y-ts.h/2,ts.w,ts.h); if(def.stats?.range){ g.beginPath(); g.strokeStyle='#FFF'; g.arc(x,y,def.stats.range*ts.w,0,Math.PI*2); g.stroke(); } g.globalAlpha=1; } }
  }

  function updateHUD(){ const t=CONFIG.CITADEL_TIERS[state.citadelTier]; byId('citadelHP').textContent=Math.max(0,Math.floor(state.citadelHP)); byId('citadelMaxHP').textContent=t.hp; byId('citadelTier').textContent=state.citadelTier; byId('gold').textContent=Math.floor(state.gold); byId('ore').textContent=Math.floor(state.ore); byId('components').textContent=Math.floor(state.components); byId('gears').textContent=Math.floor(state.gears); byId('cores').textContent=Math.floor(state.cores); byId('wave').textContent=state.wave; }

  function updateBuildMenu(){ buildMenu.innerHTML=''; byId('buildTier').textContent=state.citadelTier; const avail=[...Object.entries(CONFIG.TOWER_TYPES), ...Object.entries(CONFIG.BUILDING_TYPES)].filter(([k,d])=> (d.tier||99) <= state.citadelTier); for(const [key,data] of avail){ const btn=document.createElement('button'); btn.className='btn'; const req = (data.prerequisite?` ‚Üó‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ${CONFIG.BUILDING_TYPES[data.prerequisite]?.name||data.prerequisite}`:''); btn.textContent=`${data.name} (${data.cost?.gold||0}G)${req}`; btn.onclick=()=>{ state.buildMode=key; state.selectedEntity=null; updateSelectedInfo(); }; buildMenu.appendChild(btn); }
  }

  function updateSelectedInfo(){ const box=byId('selectedInfo'); const e=state.selectedEntity; if(!e){ box.innerHTML='<small style="color:var(--mut)">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏õ‡πâ‡∏≠‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î</small>'; return; } if(e.type==='tower'){ const s=e.stats; const fmt=n=>Number(n).toFixed(1); box.innerHTML=`<b>${e.def.name}</b> (Lv.${e.level})<br>DMG: ${fmt(s.dmg)} | RNG: ${fmt(s.range)} | RATE: ${fmt(s.rate)} /s`;
      // upgrades
      const up=e.def.upgrades||{}; const wrap=document.createElement('div'); wrap.style.marginTop='6px'; for(const [k,ud] of Object.entries(up)){ const b=document.createElement('button'); b.className='btn'; b.style.marginRight='6px'; b.textContent=`‡∏≠‡∏±‡∏õ ${k.toUpperCase()} (-${ud.cost.ore||0} Ore)`; b.onclick=()=>upgradeTower(e,k); wrap.appendChild(b); } box.appendChild(wrap);
    } else { box.innerHTML=`<b>${e.def.name}</b><br><small style="color:var(--mut)">‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</small>`; }
  }

  function upgradeTower(tower, key){ const up=tower.def.upgrades?.[key]; if(!up) return; const cost=up.cost||{}; if(!canAfford(cost)) return toast('‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡πÑ‡∏°‡πà‡∏û‡∏≠'); pay(cost); // apply
    tower.stats[key] = (tower.stats[key]||0) * up.val; tower.level++; state.effects.push(new FloatingText(`UP ${key.toUpperCase()}`, tower.x, tower.y)); updateSelectedInfo(); updateHUD(); }

  function updateCitadelUI(){ const container=byId('citadelTiers'); container.innerHTML=''; for(let i=2;i<=4;i++){ const td=CONFIG.CITADEL_TIERS[i]; const div=document.createElement('div'); div.className='tier'; const costHtml=Object.entries(td.cost||{}).map(([k,v])=>`${v} ${k}`).join(', '); const unlocksHtml = td.unlocks.map(k=> CONFIG.TOWER_TYPES[k]?.name || CONFIG.BUILDING_TYPES[k]?.name || k).join(', '); div.innerHTML=`<h4>Tier ${i}</h4><p>‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ: ${unlocksHtml}</p><button id="upgradeTier${i}" class="btn">‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î (${costHtml||'-'})</button>`; container.appendChild(div); const btn=byId(`upgradeTier${i}`); if(state.citadelTier>=i){ btn.textContent='‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡πÅ‡∏•‡πâ‡∏ß'; btn.disabled=true; } else if(state.citadelTier!==i-1){ btn.textContent='‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î Tier ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤'; btn.disabled=true; } else { btn.onclick=()=>upgradeCitadel(); } }
  }

  function upgradeCitadel(){ const next=state.citadelTier+1; if(!CONFIG.CITADEL_TIERS[next]) return; const cost=CONFIG.CITADEL_TIERS[next].cost||{}; if(!canAfford(cost)) return toast('‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡πÑ‡∏°‡πà‡∏û‡∏≠'); pay(cost); state.citadelTier=next; state.citadelHP=CONFIG.CITADEL_TIERS[next].hp; toast(`‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡πÄ‡∏õ‡πá‡∏ô Tier ${next}!`); updateHUD(); updateCitadelUI(); updateBuildMenu(); }

  // UI Events
  byId('btnCitadel').onclick=()=>byId('citadelModal').classList.add('visible');
  byId('closeCitadelModal').onclick=()=>byId('citadelModal').classList.remove('visible');
  byId('btnSpeed').onclick=()=>{ state.speed = (state.speed===1?2:1); byId('btnSpeed').textContent=`‚è© Speed x${state.speed}`; };
  btnStart.onclick=startWave;

  // WORLD SELECT
  function setupWorldSelection(){ const worldCanvas=byId('world'); const wCtx=worldCanvas.getContext('2d'); let pending=null; function drawWorld(){ const TILE_W=worldCanvas.width/8; const TILE_H=worldCanvas.height/5; wCtx.clearRect(0,0,worldCanvas.width,worldCanvas.height); let i=0; const biomes=Object.keys(CONFIG.BIOME_MODIFIERS); const root=getComputedStyle(document.documentElement); for(let r=0;r<5;r++){ for(let c=0;c<8;c++){ const key=biomes[i%biomes.length]; const data=CONFIG.BIOME_MODIFIERS[key]; const varName=data.color.replace('var(','').replace(')',''); wCtx.fillStyle=root.getPropertyValue(varName).trim(); wCtx.fillRect(c*TILE_W, r*TILE_H, TILE_W-2, TILE_H-2); i++; } } }
    worldCanvas.onclick=(e)=>{ const rect=worldCanvas.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top; const TILE_W=worldCanvas.width/8, TILE_H=worldCanvas.height/5; const c=Math.floor(x/TILE_W), r=Math.floor(y/TILE_H); const biomes=Object.keys(CONFIG.BIOME_MODIFIERS); const idx=(r*8+c)%biomes.length; pending=biomes[idx]; const data=CONFIG.BIOME_MODIFIERS[pending]; byId('zonePreview').innerHTML=`<b>${data.name}:</b> ${data.desc}`; byId('btnConfirm').disabled=false; };
    byId('btnConfirm').onclick=async ()=>{ if(!pending) return; state.biome=pending; state.mode='play'; byId('selectionContent').style.display='none'; byId('loadingOverlay').style.display='block'; await AssetManager.loadAssets(); byId('worldOverlay').classList.remove('visible'); toast(`‡∏ï‡∏±‡πâ‡∏á‡∏ê‡∏≤‡∏ô‡πÉ‡∏ô ${CONFIG.BIOME_MODIFIERS[pending].name}`); initGame(); };
    drawWorld(); }

  // =========================
  // UTILS
  // =========================
  function resize(){ const availableWidth=document.querySelector('section').clientWidth; game.width=availableWidth; game.height=availableWidth*(CONFIG.GRID.ROWS/CONFIG.GRID.COLS); }
  function buildPath(){ const raw=[{c:0,r:7},{c:1,r:7},{c:2,r:7},{c:3,r:7},{c:4,r:7},{c:5,r:6},{c:6,r:5},{c:7,r:5},{c:8,r:5},{c:9,r:5},{c:10,r:6},{c:11,r:7},{c:12,r:8},{c:13,r:8},{c:14,r:8},{c:15,r:8},{c:16,r:7},{c:17,r:6},{c:18,r:6},{c:19,r:6},{c:20,r:6},{c:21,r:7},{c:22,r:7},{c:23,r:7}]; state.path = raw.map(p=>tileCenter(p.c,p.r)); state.pathGrid = new Set(raw.map(p=>`${p.c},${p.r}`)); }
  function TS(){ return {w:game.width/CONFIG.GRID.COLS, h:game.height/CONFIG.GRID.ROWS}; }
  function tileCenter(c,r){ const t=TS(); return {x:(c+.5)*t.w, y:(r+.5)*t.h}; }
  function worldToTile(px,py){ const t=TS(); return {c:Math.floor(px/t.w), r:Math.floor(py/t.h)}; }
  function dist(x1,y1,x2,y2){ return Math.hypot(x1-x2,y1-y2); }
  function toast(msg){ const el=document.createElement('div'); el.style.position='fixed'; el.style.bottom='20px'; el.style.left='50%'; el.style.transform='translateX(-50%)'; el.style.background='var(--pri)'; el.style.color='#0b1220'; el.style.padding='10px 20px'; el.style.borderRadius='8px'; el.style.zIndex='200'; el.textContent=msg; document.body.appendChild(el); setTimeout(()=>el.remove(), 2200); }
  function byId(id){ return document.getElementById(id); }

  // BOOT
  setupWorldSelection();
})();
</script>
</body>
</html>
